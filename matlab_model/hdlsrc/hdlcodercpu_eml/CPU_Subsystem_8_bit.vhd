-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\hdlcodercpu_eml\CPU_Subsystem_8_bit.vhd
-- Created: 2014-08-26 11:41:14
-- 
-- Generated by MATLAB 8.3 and HDL Coder 3.4
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ext_out                       ce_out        1
-- hlt                           ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CPU_Subsystem_8_bit
-- Source Path: hdlcodercpu_eml/CPU_Subsystem_8_bit
-- Hierarchy Level: 0
-- 
-- Simulink model description for hdlcodercpu_eml:
-- 
-- An 8-bit RISC Processor using MATLAB(R) Function Blocks
-- This model shows how to use Simulink(R) HDL Coder(TM) to check, 
-- generate and verify HDL for an 8-bit CPU implemented using the 
-- MATLAB Function Block.
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CPU_Subsystem_8_bit IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        master_reset                      :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        ext_out                           :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        hlt                               :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
        );
END CPU_Subsystem_8_bit;


ARCHITECTURE rtl OF CPU_Subsystem_8_bit IS

  -- Component Declarations
  COMPONENT PC_Incrementer
    PORT( jmp_offset                      :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          PC_current                      :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          PC_next                         :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT Program_Counter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          func                            :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          addr_in                         :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          addr_out                        :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT Instruction_ROM
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          addr                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          read                            :   IN    std_logic;  -- ufix1
          instr_out                       :   OUT   std_logic_vector(11 DOWNTO 0)  -- ufix12
          );
  END COMPONENT;

  COMPONENT Instruction_Register
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          func                            :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          IR_in                           :   IN    std_logic_vector(11 DOWNTO 0);  -- ufix12
          IR_out                          :   OUT   std_logic_vector(11 DOWNTO 0)  -- ufix12
          );
  END COMPONENT;

  COMPONENT Arithmetic_Logical_Unit_8_bit
    PORT( in_flags                        :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          func                            :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          alu_in                          :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          AC                              :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          alu_out                         :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
          out_flags                       :   OUT   std_logic_vector(3 DOWNTO 0)  -- ufix4
          );
  END COMPONENT;

  COMPONENT Shifter_8_bit
    PORT( select_rsvd                     :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          input                           :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          in_flags                        :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          out_flags                       :   OUT   std_logic_vector(3 DOWNTO 0);  -- ufix4
          shift_out                       :   OUT   std_logic_vector(7 DOWNTO 0)  -- int8
          );
  END COMPONENT;

  COMPONENT Control_Unit
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          data_in                         :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          in_flags                        :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          master_rst                      :   IN    std_logic;
          IR_in                           :   IN    std_logic_vector(11 DOWNTO 0);  -- ufix12
          shifter_sel                     :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
          out_flags                       :   OUT   std_logic_vector(3 DOWNTO 0);  -- ufix4
          ALU_func                        :   OUT   std_logic_vector(2 DOWNTO 0);  -- ufix3
          print_data                      :   OUT   std_logic;
          DM_addr                         :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
          DM_r_w                          :   OUT   std_logic;  -- ufix1
          AC_func                         :   OUT   std_logic_vector(2 DOWNTO 0);  -- ufix3
          AC_data                         :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
          IR_func                         :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
          PC_func                         :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
          addr_inc                        :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
          IM_read                         :   OUT   std_logic;  -- ufix1
          hlt                             :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT Accumulator
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          func                            :   IN    std_logic_vector(2 DOWNTO 0);  -- ufix3
          AC_in1                          :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          AC_in2                          :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          AC_out                          :   OUT   std_logic_vector(7 DOWNTO 0)  -- int8
          );
  END COMPONENT;

  COMPONENT SinglePortRAM_Inst0
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          din                             :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          addr                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          we                              :   IN    std_logic;
          dout                            :   OUT   std_logic_vector(7 DOWNTO 0)  -- int8
          );
  END COMPONENT;

  COMPONENT output_enable
    PORT( u                               :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          enable                          :   IN    std_logic;
          y                               :   OUT   std_logic_vector(7 DOWNTO 0)  -- int8
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : PC_Incrementer
    USE ENTITY work.PC_Incrementer(rtl);

  FOR ALL : Program_Counter
    USE ENTITY work.Program_Counter(rtl);

  FOR ALL : Instruction_ROM
    USE ENTITY work.Instruction_ROM(rtl);

  FOR ALL : Instruction_Register
    USE ENTITY work.Instruction_Register(rtl);

  FOR ALL : Arithmetic_Logical_Unit_8_bit
    USE ENTITY work.Arithmetic_Logical_Unit_8_bit(rtl);

  FOR ALL : Shifter_8_bit
    USE ENTITY work.Shifter_8_bit(rtl);

  FOR ALL : Control_Unit
    USE ENTITY work.Control_Unit(rtl);

  FOR ALL : Accumulator
    USE ENTITY work.Accumulator(rtl);

  FOR ALL : SinglePortRAM_Inst0
    USE ENTITY work.SinglePortRAM_Inst0(rtl);

  FOR ALL : output_enable
    USE ENTITY work.output_enable(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL Unit_Delay_7_out1                : std_logic;
  SIGNAL shift_out                        : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL shift_out_signed                 : signed(7 DOWNTO 0);  -- int8
  SIGNAL Unit_Delay2_out1                 : signed(7 DOWNTO 0);  -- int8
  SIGNAL addr_out                         : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL addr_out_unsigned                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Unit_Delay_4_out1                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL addr_inc                         : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL PC_next                          : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL PC_func                          : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL IM_read                          : std_logic;  -- ufix1
  SIGNAL instr_out                        : std_logic_vector(11 DOWNTO 0);  -- ufix12
  SIGNAL IR_func                          : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL IR_out                           : std_logic_vector(11 DOWNTO 0);  -- ufix12
  SIGNAL IR_out_unsigned                  : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL Unit_Delay_1_out1                : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL out_flags                        : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL ALU_func                         : std_logic_vector(2 DOWNTO 0);  -- ufix3
  SIGNAL Data_Memory_out1                 : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL AC_out                           : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL alu_out                          : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL out_flags_1                      : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL shifter_sel                      : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL out_flags_2                      : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL out_flags_unsigned               : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Unit_Delay_3_out1                : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Data_Memory_out1_signed          : signed(7 DOWNTO 0);  -- int8
  SIGNAL feedback_for_indirect_addressing : signed(7 DOWNTO 0);  -- int8
  SIGNAL print_data                       : std_logic;
  SIGNAL DM_addr                          : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL DM_r_w                           : std_logic;  -- ufix1
  SIGNAL AC_func                          : std_logic_vector(2 DOWNTO 0);  -- ufix3
  SIGNAL AC_data                          : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL hlt_tmp                          : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL y                                : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL y_signed                         : signed(7 DOWNTO 0);  -- int8
  SIGNAL Unit_Delay_6_out1                : signed(7 DOWNTO 0);  -- int8

BEGIN
  -- loading into AC
  -- 
  -- writing computation back into AC
  -- 
  -- Instruction to be executed

  -- <S1>/PC Incrementer
  u_PC_Incrementer : PC_Incrementer
    PORT MAP( jmp_offset => addr_inc,  -- int8
              PC_current => std_logic_vector(Unit_Delay_4_out1),  -- uint8
              PC_next => PC_next  -- uint8
              );

  -- <S1>/Program Counter
  u_Program_Counter : Program_Counter
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              func => PC_func,  -- ufix2
              addr_in => PC_next,  -- uint8
              addr_out => addr_out  -- uint8
              );

  -- <S1>/Instruction ROM
  u_Instruction_ROM : Instruction_ROM
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              addr => addr_out,  -- uint8
              read => IM_read,  -- ufix1
              instr_out => instr_out  -- ufix12
              );

  -- <S1>/Instruction Register
  u_Instruction_Register : Instruction_Register
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              func => IR_func,  -- ufix2
              IR_in => instr_out,  -- ufix12
              IR_out => IR_out  -- ufix12
              );

  -- <S1>/Arithmetic Logical Unit (8-bit)
  u_Arithmetic_Logical_Unit_8_bit : Arithmetic_Logical_Unit_8_bit
    PORT MAP( in_flags => out_flags,  -- ufix4
              func => ALU_func,  -- ufix3
              alu_in => Data_Memory_out1,  -- int8
              AC => AC_out,  -- int8
              alu_out => alu_out,  -- int8
              out_flags => out_flags_1  -- ufix4
              );

  -- <S1>/Shifter (8-bit)
  u_Shifter_8_bit : Shifter_8_bit
    PORT MAP( select_rsvd => shifter_sel,  -- ufix2
              input => alu_out,  -- int8
              in_flags => out_flags_1,  -- ufix4
              out_flags => out_flags_2,  -- ufix4
              shift_out => shift_out  -- int8
              );

  -- <S1>/Control Unit
  -- 
  -- <S1>/Data Type Conversion
  u_Control_Unit : Control_Unit
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              data_in => std_logic_vector(feedback_for_indirect_addressing),  -- int8
              in_flags => std_logic_vector(Unit_Delay_3_out1),  -- ufix4
              master_rst => Unit_Delay_7_out1,
              IR_in => std_logic_vector(Unit_Delay_1_out1),  -- ufix12
              shifter_sel => shifter_sel,  -- ufix2
              out_flags => out_flags,  -- ufix4
              ALU_func => ALU_func,  -- ufix3
              print_data => print_data,
              DM_addr => DM_addr,  -- uint8
              DM_r_w => DM_r_w,  -- ufix1
              AC_func => AC_func,  -- ufix3
              AC_data => AC_data,  -- int8
              IR_func => IR_func,  -- ufix2
              PC_func => PC_func,  -- ufix2
              addr_inc => addr_inc,  -- int8
              IM_read => IM_read,  -- ufix1
              hlt => hlt_tmp  -- uint8
              );

  -- <S1>/Accumulator
  u_Accumulator : Accumulator
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              func => AC_func,  -- ufix3
              AC_in1 => AC_data,  -- int8
              AC_in2 => std_logic_vector(Unit_Delay2_out1),  -- int8
              AC_out => AC_out  -- int8
              );

  -- <S1>/Data Memory
  u_SinglePortRAM_Inst0 : SinglePortRAM_Inst0
    PORT MAP( clk => clk,
              enb => clk_enable,
              din => AC_out,  -- int8
              addr => DM_addr,  -- uint8
              we => DM_r_w,
              dout => Data_Memory_out1  -- int8
              );

  -- <S1>/output_enable
  u_output_enable : output_enable
    PORT MAP( u => Data_Memory_out1,  -- int8
              enable => print_data,
              y => y  -- int8
              );

  enb <= clk_enable;

  -- <S1>/Unit Delay 7
  Unit_Delay_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Unit_Delay_7_out1 <= '0';
      ELSIF enb = '1' THEN
        Unit_Delay_7_out1 <= master_reset;
      END IF;
    END IF;
  END PROCESS Unit_Delay_7_process;


  shift_out_signed <= signed(shift_out);

  -- <S1>/Unit Delay2
  Unit_Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Unit_Delay2_out1 <= to_signed(2#00000000#, 8);
      ELSIF enb = '1' THEN
        Unit_Delay2_out1 <= shift_out_signed;
      END IF;
    END IF;
  END PROCESS Unit_Delay2_process;


  addr_out_unsigned <= unsigned(addr_out);

  -- <S1>/Unit Delay 4
  Unit_Delay_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Unit_Delay_4_out1 <= to_unsigned(2#00000000#, 8);
      ELSIF enb = '1' THEN
        Unit_Delay_4_out1 <= addr_out_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_4_process;


  IR_out_unsigned <= unsigned(IR_out);

  -- <S1>/Unit Delay 1
  Unit_Delay_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Unit_Delay_1_out1 <= to_unsigned(2#000000000000#, 12);
      ELSIF enb = '1' THEN
        Unit_Delay_1_out1 <= IR_out_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_1_process;


  out_flags_unsigned <= unsigned(out_flags_2);

  -- <S1>/Unit Delay 3
  Unit_Delay_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Unit_Delay_3_out1 <= to_unsigned(2#0000#, 4);
      ELSIF enb = '1' THEN
        Unit_Delay_3_out1 <= out_flags_unsigned;
      END IF;
    END IF;
  END PROCESS Unit_Delay_3_process;


  Data_Memory_out1_signed <= signed(Data_Memory_out1);

  -- <S1>/Unit Delay 5
  Unit_Delay_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        feedback_for_indirect_addressing <= to_signed(2#00000000#, 8);
      ELSIF enb = '1' THEN
        feedback_for_indirect_addressing <= Data_Memory_out1_signed;
      END IF;
    END IF;
  END PROCESS Unit_Delay_5_process;


  y_signed <= signed(y);

  -- <S1>/Unit Delay 6
  Unit_Delay_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Unit_Delay_6_out1 <= to_signed(2#00000000#, 8);
      ELSIF enb = '1' THEN
        Unit_Delay_6_out1 <= y_signed;
      END IF;
    END IF;
  END PROCESS Unit_Delay_6_process;


  ext_out <= std_logic_vector(Unit_Delay_6_out1);

  ce_out <= clk_enable;

  -- <S1>/Scope

  hlt <= hlt_tmp;

END rtl;

